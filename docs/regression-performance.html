<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Hands-on Machine Learning with R</title>
  <meta name="description" content="A Machine Learning Algorithmic Deep Dive Using R.">
  <meta name="generator" content="bookdown 0.7 and GitBook 2.6.7">

  <meta property="og:title" content="Hands-on Machine Learning with R" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="A Machine Learning Algorithmic Deep Dive Using R." />
  <meta name="github-repo" content="bradleyboehmke/hands-on-machine-learning-with-r" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Hands-on Machine Learning with R" />
  
  <meta name="twitter:description" content="A Machine Learning Algorithmic Deep Dive Using R." />
  



<meta name="date" content="2018-08-01">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="intro.html">
<link rel="next" href="regularized-regression.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<script src="libs/htmlwidgets-1.2/htmlwidgets.js"></script>
<script src="libs/plotly-binding-4.7.1/plotly.js"></script>
<script src="libs/typedarray-0.1/typedarray.min.js"></script>
<link href="libs/crosstalk-1.0.0/css/crosstalk.css" rel="stylesheet" />
<script src="libs/crosstalk-1.0.0/js/crosstalk.min.js"></script>
<link href="libs/plotlyjs-1.29.2/plotly-htmlwidgets.css" rel="stylesheet" />
<script src="libs/plotlyjs-1.29.2/plotly-latest.min.js"></script>


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Hands-on Machine Learning with R</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a><ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#who-should-read-this"><i class="fa fa-check"></i>Who should read this</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#why-r"><i class="fa fa-check"></i>Why R</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#structure-of-the-book"><i class="fa fa-check"></i>Structure of the book</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#conventions-used-in-this-book"><i class="fa fa-check"></i>Conventions used in this book</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#additional-resources"><i class="fa fa-check"></i>Additional resources</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#feedback"><i class="fa fa-check"></i>Feedback</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#acknowledgments"><i class="fa fa-check"></i>Acknowledgments</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#software-information"><i class="fa fa-check"></i>Software information</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul>
<li class="chapter" data-level="1.1" data-path="intro.html"><a href="intro.html#supervised-learning"><i class="fa fa-check"></i><b>1.1</b> Supervised Learning</a><ul>
<li class="chapter" data-level="1.1.1" data-path="intro.html"><a href="intro.html#regression-problems"><i class="fa fa-check"></i><b>1.1.1</b> Regression problems</a></li>
<li class="chapter" data-level="1.1.2" data-path="intro.html"><a href="intro.html#classification-problems"><i class="fa fa-check"></i><b>1.1.2</b> Classification problems</a></li>
<li class="chapter" data-level="1.1.3" data-path="intro.html"><a href="intro.html#algorithm-comparison-guide"><i class="fa fa-check"></i><b>1.1.3</b> Algorithm Comparison Guide</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="intro.html"><a href="intro.html#unsupervised-learning"><i class="fa fa-check"></i><b>1.2</b> Unsupervised Learning</a><ul>
<li class="chapter" data-level="1.2.1" data-path="intro.html"><a href="intro.html#algorithm-decision-guide"><i class="fa fa-check"></i><b>1.2.1</b> Algorithm Decision Guide</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="intro.html"><a href="intro.html#machine-learning-interpretability"><i class="fa fa-check"></i><b>1.3</b> Machine learning interpretability</a></li>
<li class="chapter" data-level="1.4" data-path="intro.html"><a href="intro.html#data"><i class="fa fa-check"></i><b>1.4</b> The data sets</a></li>
</ul></li>
<li class="part"><span><b>I Supervised Learning</b></span></li>
<li class="chapter" data-level="2" data-path="regression-performance.html"><a href="regression-performance.html"><i class="fa fa-check"></i><b>2</b> Preparing for Supervised Machine Learning</a><ul>
<li class="chapter" data-level="2.1" data-path="regression-performance.html"><a href="regression-performance.html#reg_perf_prereq"><i class="fa fa-check"></i><b>2.1</b> Prerequisites</a></li>
<li class="chapter" data-level="2.2" data-path="regression-performance.html"><a href="regression-performance.html#reg_perf_split"><i class="fa fa-check"></i><b>2.2</b> Data splitting</a><ul>
<li class="chapter" data-level="2.2.1" data-path="regression-performance.html"><a href="regression-performance.html#spending-our-data-wisely"><i class="fa fa-check"></i><b>2.2.1</b> Spending our data wisely</a></li>
<li class="chapter" data-level="2.2.2" data-path="regression-performance.html"><a href="regression-performance.html#simple-random-sampling"><i class="fa fa-check"></i><b>2.2.2</b> Simple random sampling</a></li>
<li class="chapter" data-level="2.2.3" data-path="regression-performance.html"><a href="regression-performance.html#stratified-sampling"><i class="fa fa-check"></i><b>2.2.3</b> Stratified sampling</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="regression-performance.html"><a href="regression-performance.html#reg_perf_feat"><i class="fa fa-check"></i><b>2.3</b> Feature engineering</a><ul>
<li class="chapter" data-level="2.3.1" data-path="regression-performance.html"><a href="regression-performance.html#response-transformation"><i class="fa fa-check"></i><b>2.3.1</b> Response Transformation</a></li>
<li class="chapter" data-level="2.3.2" data-path="regression-performance.html"><a href="regression-performance.html#predictor-transformation"><i class="fa fa-check"></i><b>2.3.2</b> Predictor Transformation</a></li>
<li class="chapter" data-level="2.3.3" data-path="regression-performance.html"><a href="regression-performance.html#one-hot-encoding"><i class="fa fa-check"></i><b>2.3.3</b> One-hot encoding</a></li>
<li class="chapter" data-level="2.3.4" data-path="regression-performance.html"><a href="regression-performance.html#standardizing"><i class="fa fa-check"></i><b>2.3.4</b> Standardizing</a></li>
<li class="chapter" data-level="2.3.5" data-path="regression-performance.html"><a href="regression-performance.html#alternative-feature-transformation"><i class="fa fa-check"></i><b>2.3.5</b> Alternative Feature Transformation</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="regression-performance.html"><a href="regression-performance.html#reg_perf_model"><i class="fa fa-check"></i><b>2.4</b> Basic model formulation</a></li>
<li class="chapter" data-level="2.5" data-path="regression-performance.html"><a href="regression-performance.html#reg_perf_tune"><i class="fa fa-check"></i><b>2.5</b> Model tuning</a></li>
<li class="chapter" data-level="2.6" data-path="regression-performance.html"><a href="regression-performance.html#cv"><i class="fa fa-check"></i><b>2.6</b> Cross Validation for Generalization</a></li>
<li class="chapter" data-level="2.7" data-path="regression-performance.html"><a href="regression-performance.html#reg_perf_eval"><i class="fa fa-check"></i><b>2.7</b> Model evaluation</a><ul>
<li class="chapter" data-level="2.7.1" data-path="regression-performance.html"><a href="regression-performance.html#regression-models"><i class="fa fa-check"></i><b>2.7.1</b> Regression models</a></li>
<li class="chapter" data-level="2.7.2" data-path="regression-performance.html"><a href="regression-performance.html#classification-models"><i class="fa fa-check"></i><b>2.7.2</b> Classification models</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="regularized-regression.html"><a href="regularized-regression.html"><i class="fa fa-check"></i><b>3</b> Regularized Regression</a><ul>
<li class="chapter" data-level="3.1" data-path="regularized-regression.html"><a href="regularized-regression.html#glm-req"><i class="fa fa-check"></i><b>3.1</b> Prerequisites</a></li>
<li class="chapter" data-level="3.2" data-path="regularized-regression.html"><a href="regularized-regression.html#glm-pros-cons"><i class="fa fa-check"></i><b>3.2</b> Advantages &amp; Disadvantages</a></li>
<li class="chapter" data-level="3.3" data-path="regularized-regression.html"><a href="regularized-regression.html#glm-why"><i class="fa fa-check"></i><b>3.3</b> The Idea</a><ul>
<li class="chapter" data-level="3.3.1" data-path="regularized-regression.html"><a href="regularized-regression.html#multicollinearity"><i class="fa fa-check"></i><b>3.3.1</b> 1. Multicollinearity</a></li>
<li class="chapter" data-level="3.3.2" data-path="regularized-regression.html"><a href="regularized-regression.html#insufficient-solution"><i class="fa fa-check"></i><b>3.3.2</b> 2. Insufficient solution</a></li>
<li class="chapter" data-level="3.3.3" data-path="regularized-regression.html"><a href="regularized-regression.html#interpretability"><i class="fa fa-check"></i><b>3.3.3</b> 3. Interpretability</a></li>
<li class="chapter" data-level="3.3.4" data-path="regularized-regression.html"><a href="regularized-regression.html#regularized_regress"><i class="fa fa-check"></i><b>3.3.4</b> Regularized Models</a><ul>
<li class="chapter" data-level="3.3.4.1" data-path="regularized-regression.html"><a href="regularized-regression.html#ridge"><i class="fa fa-check"></i><b>3.3.4.1</b> Ridge penalty</a></li>
<li class="chapter" data-level="3.3.4.2" data-path="regularized-regression.html"><a href="regularized-regression.html#lasso"><i class="fa fa-check"></i><b>3.3.4.2</b> Lasso penalty</a></li>
<li class="chapter" data-level="3.3.4.3" data-path="regularized-regression.html"><a href="regularized-regression.html#elastic"><i class="fa fa-check"></i><b>3.3.4.3</b> Elastic nets</a></li>
</ul></li>
<li class="chapter" data-level="3.3.5" data-path="regularized-regression.html"><a href="regularized-regression.html#glm-tuning"><i class="fa fa-check"></i><b>3.3.5</b> Tuning</a></li>
<li class="chapter" data-level="3.3.6" data-path="regularized-regression.html"><a href="regularized-regression.html#glm-pkg-implementation"><i class="fa fa-check"></i><b>3.3.6</b> Package implementation</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="regularized-regression.html"><a href="regularized-regression.html#glm-regression"><i class="fa fa-check"></i><b>3.4</b> Implementation: Regression</a><ul>
<li class="chapter" data-level="3.4.1" data-path="regularized-regression.html"><a href="regularized-regression.html#regression-glm-glmnet"><i class="fa fa-check"></i><b>3.4.1</b> <code>glmnet</code></a><ul>
<li class="chapter" data-level="3.4.1.1" data-path="regularized-regression.html"><a href="regularized-regression.html#regression-glmnet-basic"><i class="fa fa-check"></i><b>3.4.1.1</b> Basic implementation</a></li>
<li class="chapter" data-level="3.4.1.2" data-path="regularized-regression.html"><a href="regularized-regression.html#regression-glmnet-tune"><i class="fa fa-check"></i><b>3.4.1.2</b> Tuning</a></li>
<li class="chapter" data-level="3.4.1.3" data-path="regularized-regression.html"><a href="regularized-regression.html#regression-glmnet-visualizing"><i class="fa fa-check"></i><b>3.4.1.3</b> Visual interpretation</a></li>
<li class="chapter" data-level="3.4.1.4" data-path="regularized-regression.html"><a href="regularized-regression.html#regression-glmnet-predict"><i class="fa fa-check"></i><b>3.4.1.4</b> Predicting</a></li>
</ul></li>
<li class="chapter" data-level="3.4.2" data-path="regularized-regression.html"><a href="regularized-regression.html#regression-regularize-h2o"><i class="fa fa-check"></i><b>3.4.2</b> <code>h2o</code></a><ul>
<li class="chapter" data-level="3.4.2.1" data-path="regularized-regression.html"><a href="regularized-regression.html#regression-h2o-basic"><i class="fa fa-check"></i><b>3.4.2.1</b> Basic implementation</a></li>
<li class="chapter" data-level="3.4.2.2" data-path="regularized-regression.html"><a href="regularized-regression.html#regression-h2o-tune"><i class="fa fa-check"></i><b>3.4.2.2</b> Tuning</a></li>
<li class="chapter" data-level="3.4.2.3" data-path="regularized-regression.html"><a href="regularized-regression.html#regression-h2o-viz"><i class="fa fa-check"></i><b>3.4.2.3</b> Visual interpretation</a></li>
<li class="chapter" data-level="3.4.2.4" data-path="regularized-regression.html"><a href="regularized-regression.html#regression-h2o-predict"><i class="fa fa-check"></i><b>3.4.2.4</b> Predicting</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3.5" data-path="regularized-regression.html"><a href="regularized-regression.html#glm-binary-classification"><i class="fa fa-check"></i><b>3.5</b> Implementation: Binary Classification</a><ul>
<li class="chapter" data-level="3.5.1" data-path="regularized-regression.html"><a href="regularized-regression.html#classification-binary-glm-glmnet"><i class="fa fa-check"></i><b>3.5.1</b> <code>glmnet</code></a><ul>
<li class="chapter" data-level="3.5.1.1" data-path="regularized-regression.html"><a href="regularized-regression.html#classification-binary-glmnet-basic"><i class="fa fa-check"></i><b>3.5.1.1</b> Basic implementation</a></li>
<li class="chapter" data-level="3.5.1.2" data-path="regularized-regression.html"><a href="regularized-regression.html#classification-binaryglmnet-tune"><i class="fa fa-check"></i><b>3.5.1.2</b> Tuning</a></li>
<li class="chapter" data-level="3.5.1.3" data-path="regularized-regression.html"><a href="regularized-regression.html#classification-binary-glmnet-visualizing"><i class="fa fa-check"></i><b>3.5.1.3</b> Visual interpretation</a></li>
<li class="chapter" data-level="3.5.1.4" data-path="regularized-regression.html"><a href="regularized-regression.html#classification-binary-glmnet-predict"><i class="fa fa-check"></i><b>3.5.1.4</b> Predicting</a></li>
</ul></li>
<li class="chapter" data-level="3.5.2" data-path="regularized-regression.html"><a href="regularized-regression.html#classification-binaryglm-h2o"><i class="fa fa-check"></i><b>3.5.2</b> <code>h2o</code></a><ul>
<li class="chapter" data-level="3.5.2.1" data-path="regularized-regression.html"><a href="regularized-regression.html#h2o-glm-classification-binary-basic"><i class="fa fa-check"></i><b>3.5.2.1</b> Basic implementation</a></li>
<li class="chapter" data-level="3.5.2.2" data-path="regularized-regression.html"><a href="regularized-regression.html#glm-h2o-classification-binary-tune"><i class="fa fa-check"></i><b>3.5.2.2</b> Tuning</a></li>
<li class="chapter" data-level="3.5.2.3" data-path="regularized-regression.html"><a href="regularized-regression.html#glm-h2o-classification-binary-viz"><i class="fa fa-check"></i><b>3.5.2.3</b> Visual Interpretation</a></li>
<li class="chapter" data-level="3.5.2.4" data-path="regularized-regression.html"><a href="regularized-regression.html#glm-h2o-classification-binary-predict"><i class="fa fa-check"></i><b>3.5.2.4</b> Predicting</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3.6" data-path="regularized-regression.html"><a href="regularized-regression.html#glm-multinomial-classification"><i class="fa fa-check"></i><b>3.6</b> Implementation: Multinomial Classification</a><ul>
<li class="chapter" data-level="3.6.1" data-path="regularized-regression.html"><a href="regularized-regression.html#classification-multi-glm-glmnet"><i class="fa fa-check"></i><b>3.6.1</b> <code>glmnet</code></a><ul>
<li class="chapter" data-level="3.6.1.1" data-path="regularized-regression.html"><a href="regularized-regression.html#classification-multi-glmnet-basic"><i class="fa fa-check"></i><b>3.6.1.1</b> Basic implementation</a></li>
<li class="chapter" data-level="3.6.1.2" data-path="regularized-regression.html"><a href="regularized-regression.html#classification-multi-glmnet-tune"><i class="fa fa-check"></i><b>3.6.1.2</b> Tuning</a></li>
<li class="chapter" data-level="3.6.1.3" data-path="regularized-regression.html"><a href="regularized-regression.html#classification-multi-glmnet-visualizing"><i class="fa fa-check"></i><b>3.6.1.3</b> Visual interpretation</a></li>
<li class="chapter" data-level="3.6.1.4" data-path="regularized-regression.html"><a href="regularized-regression.html#classification-multi-glmnet-predict"><i class="fa fa-check"></i><b>3.6.1.4</b> Predicting</a></li>
</ul></li>
<li class="chapter" data-level="3.6.2" data-path="regularized-regression.html"><a href="regularized-regression.html#classification-multinomial-glm-h2o"><i class="fa fa-check"></i><b>3.6.2</b> <code>h2o</code></a><ul>
<li class="chapter" data-level="3.6.2.1" data-path="regularized-regression.html"><a href="regularized-regression.html#h2o-glm-classification-multinomial-basic"><i class="fa fa-check"></i><b>3.6.2.1</b> Basic implementation</a></li>
<li class="chapter" data-level="3.6.2.2" data-path="regularized-regression.html"><a href="regularized-regression.html#glm-h2o-classification-multinomial-tune"><i class="fa fa-check"></i><b>3.6.2.2</b> Tuning</a></li>
<li class="chapter" data-level="3.6.2.3" data-path="regularized-regression.html"><a href="regularized-regression.html#glm-h2o-classification-multinomial-viz"><i class="fa fa-check"></i><b>3.6.2.3</b> Visual Interpretation</a></li>
<li class="chapter" data-level="3.6.2.4" data-path="regularized-regression.html"><a href="regularized-regression.html#glm-h2o-classification-multinomial-predict"><i class="fa fa-check"></i><b>3.6.2.4</b> Predicting</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3.7" data-path="regularized-regression.html"><a href="regularized-regression.html#glm-learning"><i class="fa fa-check"></i><b>3.7</b> Learning More</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="random-forest.html"><a href="random-forest.html"><i class="fa fa-check"></i><b>4</b> Random Forest</a><ul>
<li class="chapter" data-level="4.1" data-path="random-forest.html"><a href="random-forest.html#rf-requirements"><i class="fa fa-check"></i><b>4.1</b> Prerequisites</a></li>
<li class="chapter" data-level="4.2" data-path="random-forest.html"><a href="random-forest.html#rf-proscons"><i class="fa fa-check"></i><b>4.2</b> Advantages &amp; Disadvantages</a></li>
<li class="chapter" data-level="4.3" data-path="random-forest.html"><a href="random-forest.html#rf-idea"><i class="fa fa-check"></i><b>4.3</b> The Idea</a><ul>
<li class="chapter" data-level="4.3.1" data-path="random-forest.html"><a href="random-forest.html#rf-oob"><i class="fa fa-check"></i><b>4.3.1</b> OOB error vs. test set error</a></li>
<li class="chapter" data-level="4.3.2" data-path="random-forest.html"><a href="random-forest.html#rf-tune"><i class="fa fa-check"></i><b>4.3.2</b> Tuning</a></li>
<li class="chapter" data-level="4.3.3" data-path="random-forest.html"><a href="random-forest.html#rf-pkgs"><i class="fa fa-check"></i><b>4.3.3</b> Package implementation</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="random-forest.html"><a href="random-forest.html#rf-regression"><i class="fa fa-check"></i><b>4.4</b> Implementation: Regression</a><ul>
<li class="chapter" data-level="4.4.1" data-path="random-forest.html"><a href="random-forest.html#ranger-regression"><i class="fa fa-check"></i><b>4.4.1</b> <code>ranger</code></a><ul>
<li class="chapter" data-level="4.4.1.1" data-path="random-forest.html"><a href="random-forest.html#ranger-regression-basic"><i class="fa fa-check"></i><b>4.4.1.1</b> Basic implementation</a></li>
<li class="chapter" data-level="4.4.1.2" data-path="random-forest.html"><a href="random-forest.html#ranger-regression-tune"><i class="fa fa-check"></i><b>4.4.1.2</b> Tuning</a></li>
<li class="chapter" data-level="4.4.1.3" data-path="random-forest.html"><a href="random-forest.html#ranger-regression-viz"><i class="fa fa-check"></i><b>4.4.1.3</b> Visual interpretation</a></li>
<li class="chapter" data-level="4.4.1.4" data-path="random-forest.html"><a href="random-forest.html#ranger-regression-predic"><i class="fa fa-check"></i><b>4.4.1.4</b> Predicting</a></li>
</ul></li>
<li class="chapter" data-level="4.4.2" data-path="random-forest.html"><a href="random-forest.html#h2o-rf-regression"><i class="fa fa-check"></i><b>4.4.2</b> <code>h20</code></a><ul>
<li class="chapter" data-level="4.4.2.1" data-path="random-forest.html"><a href="random-forest.html#rf-h2o-regression-basic"><i class="fa fa-check"></i><b>4.4.2.1</b> Basic implementation</a></li>
<li class="chapter" data-level="4.4.2.2" data-path="random-forest.html"><a href="random-forest.html#rf-h2o-regression-tune"><i class="fa fa-check"></i><b>4.4.2.2</b> Tuning</a></li>
<li class="chapter" data-level="4.4.2.3" data-path="random-forest.html"><a href="random-forest.html#rf-h2o-regression-viz"><i class="fa fa-check"></i><b>4.4.2.3</b> Visualizing results</a></li>
<li class="chapter" data-level="4.4.2.4" data-path="random-forest.html"><a href="random-forest.html#rf-h2o-regression-predict"><i class="fa fa-check"></i><b>4.4.2.4</b> Predicting</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4.5" data-path="random-forest.html"><a href="random-forest.html#rf-binary-classification"><i class="fa fa-check"></i><b>4.5</b> Implementation: Binary Classification</a><ul>
<li class="chapter" data-level="4.5.1" data-path="random-forest.html"><a href="random-forest.html#ranger-rf-binary-classification"><i class="fa fa-check"></i><b>4.5.1</b> <code>ranger</code></a><ul>
<li class="chapter" data-level="4.5.1.1" data-path="random-forest.html"><a href="random-forest.html#ranger-binary-classification-basic"><i class="fa fa-check"></i><b>4.5.1.1</b> Basic implementation</a></li>
<li class="chapter" data-level="4.5.1.2" data-path="random-forest.html"><a href="random-forest.html#ranger-rf-binary-classification-tune"><i class="fa fa-check"></i><b>4.5.1.2</b> Tuning</a></li>
<li class="chapter" data-level="4.5.1.3" data-path="random-forest.html"><a href="random-forest.html#ranger-rf-binary-classification-viz"><i class="fa fa-check"></i><b>4.5.1.3</b> Visualizing results</a></li>
<li class="chapter" data-level="4.5.1.4" data-path="random-forest.html"><a href="random-forest.html#ranger-rf-binary-classification-predict"><i class="fa fa-check"></i><b>4.5.1.4</b> Predicting</a></li>
</ul></li>
<li class="chapter" data-level="4.5.2" data-path="random-forest.html"><a href="random-forest.html#h2o-rf-binary-classification"><i class="fa fa-check"></i><b>4.5.2</b> <code>h20</code></a><ul>
<li class="chapter" data-level="4.5.2.1" data-path="random-forest.html"><a href="random-forest.html#h2o-rf-binary-classification-basic"><i class="fa fa-check"></i><b>4.5.2.1</b> Basic implementation</a></li>
<li class="chapter" data-level="4.5.2.2" data-path="random-forest.html"><a href="random-forest.html#h2o-rf-multi-classification-tune"><i class="fa fa-check"></i><b>4.5.2.2</b> Tuning</a></li>
<li class="chapter" data-level="4.5.2.3" data-path="random-forest.html"><a href="random-forest.html#h2o-rf-binary-classification-viz"><i class="fa fa-check"></i><b>4.5.2.3</b> Visualizing results</a></li>
<li class="chapter" data-level="4.5.2.4" data-path="random-forest.html"><a href="random-forest.html#h2o-rf-binary-classification-predict"><i class="fa fa-check"></i><b>4.5.2.4</b> Predicting</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4.6" data-path="random-forest.html"><a href="random-forest.html#rf-multi"><i class="fa fa-check"></i><b>4.6</b> Implementation: Multinomial Classification</a><ul>
<li class="chapter" data-level="4.6.1" data-path="random-forest.html"><a href="random-forest.html#rf-ranger-multi"><i class="fa fa-check"></i><b>4.6.1</b> <code>ranger</code></a><ul>
<li class="chapter" data-level="4.6.1.1" data-path="random-forest.html"><a href="random-forest.html#ranger-multi-basic"><i class="fa fa-check"></i><b>4.6.1.1</b> Basic implementation</a></li>
<li class="chapter" data-level="4.6.1.2" data-path="random-forest.html"><a href="random-forest.html#ranger-multi-tune"><i class="fa fa-check"></i><b>4.6.1.2</b> Tuning</a></li>
<li class="chapter" data-level="4.6.1.3" data-path="random-forest.html"><a href="random-forest.html#ranger-multi-viz"><i class="fa fa-check"></i><b>4.6.1.3</b> Visual interpretation</a></li>
<li class="chapter" data-level="4.6.1.4" data-path="random-forest.html"><a href="random-forest.html#ranger-multi-predict"><i class="fa fa-check"></i><b>4.6.1.4</b> Predicting</a></li>
</ul></li>
<li class="chapter" data-level="4.6.2" data-path="random-forest.html"><a href="random-forest.html#rf-h2o-multi"><i class="fa fa-check"></i><b>4.6.2</b> <code>h2o</code></a><ul>
<li class="chapter" data-level="4.6.2.1" data-path="random-forest.html"><a href="random-forest.html#rf-h2o-multi-basic"><i class="fa fa-check"></i><b>4.6.2.1</b> Basic implementation</a></li>
<li class="chapter" data-level="4.6.2.2" data-path="random-forest.html"><a href="random-forest.html#rf-h2o-multi-tune"><i class="fa fa-check"></i><b>4.6.2.2</b> Tuning</a></li>
<li class="chapter" data-level="4.6.2.3" data-path="random-forest.html"><a href="random-forest.html#rf-h2o-multi-viz"><i class="fa fa-check"></i><b>4.6.2.3</b> Visual interpretation</a></li>
<li class="chapter" data-level="4.6.2.4" data-path="random-forest.html"><a href="random-forest.html#rf-h2o-multi-predict"><i class="fa fa-check"></i><b>4.6.2.4</b> Predicting</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4.7" data-path="random-forest.html"><a href="random-forest.html#rf-learn"><i class="fa fa-check"></i><b>4.7</b> Learning More</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Hands-on Machine Learning with R</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="regression-performance" class="section level1">
<h1><span class="header-section-number">Chapter 2</span> Preparing for Supervised Machine Learning</h1>
<p><img src="images/modeling_process2.png"  style="float:right; margin: 5px 0px 0px 10px; width: 50%; height: 50%;" /></p>
<p>Machine learning is a very iterative process. If performed and interpreted correctly, we can have great confidence in our outcomes. If not, the results will be useless. Approaching machine learning correctly means approaching it strategically by spending our data wisely on learning and validation procedures, properly pre-processing variables, minimizing data leakage, tuning hyperparameters, and assessing model performance. Before introducing specific algorithms, this chapter introduces concepts that are commonly required in the supervised machine learning process and that you’ll see briskly covered in each chapter.</p>
<div id="reg_perf_prereq" class="section level2">
<h2><span class="header-section-number">2.1</span> Prerequisites</h2>
<p>This chapter leverages the following packages.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(rsample)
<span class="kw">library</span>(caret)
<span class="kw">library</span>(h2o)
<span class="kw">library</span>(dplyr)

<span class="co"># turn off progress bars</span>
<span class="kw">h2o.no_progress</span>()

<span class="co"># launch h2o</span>
<span class="kw">h2o.init</span>()
## 
## H2O is not running yet, starting it now...
## 
## Note:  In case of errors look at the following log files:
##     /var/folders/ws/qs4y2bnx1xs_4y9t0zbdjsvh0000gn/T//Rtmp0ENAPo/h2o_bradboehmke_started_from_r.out
##     /var/folders/ws/qs4y2bnx1xs_4y9t0zbdjsvh0000gn/T//Rtmp0ENAPo/h2o_bradboehmke_started_from_r.err
## 
## 
## Starting H2O JVM and connecting: .. Connection successful!
## 
## R is connected to the H2O cluster: 
##     H2O cluster uptime:         2 seconds 750 milliseconds 
##     H2O cluster timezone:       America/New_York 
##     H2O data parsing timezone:  UTC 
##     H2O cluster version:        3.18.0.11 
##     H2O cluster version age:    2 months and 8 days  
##     H2O cluster name:           H2O_started_from_R_bradboehmke_cki800 
##     H2O cluster total nodes:    1 
##     H2O cluster total memory:   1.78 GB 
##     H2O cluster total cores:    4 
##     H2O cluster allowed cores:  4 
##     H2O cluster healthy:        TRUE 
##     H2O Connection ip:          localhost 
##     H2O Connection port:        54321 
##     H2O Connection proxy:       NA 
##     H2O Internal Security:      FALSE 
##     H2O API Extensions:         XGBoost, Algos, AutoML, Core V3, Core V4 
##     R Version:                  R version 3.5.1 (2018-07-02)</code></pre></div>
<p>To illustrate some of the concepts, we will use the Ames Housing data and employee attrition data introduced in Chapter <a href="intro.html#intro">1</a>. Throughout this book, I’ll demonstrate approaches with regular data frames. However, since many of the supervised machine learning chapters leverage the <strong>h2o</strong> package, we’ll also show how to do some of the tasks with H2O objects. This requires your data to be in an H2O object, which you can convert any data frame easily with <code>as.h2o</code>.</p>
<div class="rmdwarning">
<p>
If you try to convert the original <code>rsample::attrition</code> data set to an H2O object an error will occur. This is because several variables are <em>ordered factors</em> and H2O has no way of handling this data type. Consequently, you must convert any ordered factors to unordered.
</p>
</div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># ames data</span>
ames &lt;-<span class="st"> </span>AmesHousing<span class="op">::</span><span class="kw">make_ames</span>()
ames.h2o &lt;-<span class="st"> </span><span class="kw">as.h2o</span>(ames)

<span class="co"># attrition data</span>
churn &lt;-<span class="st"> </span>rsample<span class="op">::</span>attrition <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate_if</span>(is.ordered, factor, <span class="dt">ordered =</span> <span class="ot">FALSE</span>)
churn.h2o &lt;-<span class="st"> </span><span class="kw">as.h2o</span>(churn)</code></pre></div>
</div>
<div id="reg_perf_split" class="section level2">
<h2><span class="header-section-number">2.2</span> Data splitting</h2>
<div id="spending-our-data-wisely" class="section level3">
<h3><span class="header-section-number">2.2.1</span> Spending our data wisely</h3>
<p>A major goal of the machine learning process is to find an algorithm <span class="math inline">\(f(x)\)</span> that most accurately predicts future values (<span class="math inline">\(y\)</span>) based on a set of inputs (<span class="math inline">\(x\)</span>). In other words, we want an algorithm that not only fits well to our past data, but more importantly, one that predicts a future outcome accurately. This is called the <strong><em>generalizability</em></strong> of our algorithm. How we <em>“spend”</em> our data will help us understand how well our algorithm generalizes to unseen data.</p>
<p>To provide an accurate understanding of the generalizability of our final optimal model, we split our data into training and test data sets:</p>
<ul>
<li><strong>Training Set</strong>: these data are used to train our algorithms and tune hyper-parameters.</li>
<li><strong>Test Set</strong>: having chosen a final model, these data are used to estimate its prediction error (generalization error). These data should <em>not be used during model training!</em></li>
</ul>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-2"></span>
<img src="images/data_split.png" alt="Splitting data into training and test sets." width="175" />
<p class="caption">
Figure 2.1: Splitting data into training and test sets.
</p>
</div>
<p>Given a fixed amount of data, typical recommendations for splitting your data into training-testing splits include 60% (training) - 40% (testing), 70%-30%, or 80%-20%. Generally speaking, these are appropriate guidelines to follow; however, it is good to keep in mind that as your overall data set gets smaller,</p>
<ul>
<li>spending too much in training (<span class="math inline">\(&gt;80\%\)</span>) won’t allow us to get a good assessment of predictive performance. We may find a model that fits the training data very well, but is not generalizable (overfitting),</li>
<li>sometimes too much spent in testing (<span class="math inline">\(&gt;40\%\)</span>) won’t allow us to get a good assessment of model parameters</li>
</ul>
<p>In today’s data-rich environment, typically, we are not lacking in the quantity of observations, so a 70-30 split is often sufficient. The two most common ways of splitting data include <strong><em>simple random sampling</em></strong> and <strong><em>stratified sampling</em></strong>.</p>
</div>
<div id="simple-random-sampling" class="section level3">
<h3><span class="header-section-number">2.2.2</span> Simple random sampling</h3>
<p>The simplest way to split the data into training and test sets is to take a simple random sample. This does not control for any data attributes, such as the percentage of data represented in your response variable (<span class="math inline">\(y\)</span>). There are multiple ways to split our data. Here we show four options to produce a 70-30 split (note that setting the seed value allows you to reproduce your randomized splits):</p>
<div class="rmdnote">
<p>
Sampling is a random process so setting the random number generator with a common seed allows for reproducible results. Throughout this book I will use the number <em>123</em> often for reproducibility but the number itself has no special meaning.
</p>
</div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># base R</span>
<span class="kw">set.seed</span>(<span class="dv">123</span>)
index_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(ames), <span class="kw">round</span>(<span class="kw">nrow</span>(ames) <span class="op">*</span><span class="st"> </span><span class="fl">0.7</span>))
train_<span class="dv">1</span> &lt;-<span class="st"> </span>ames[index_<span class="dv">1</span>, ]
test_<span class="dv">1</span>  &lt;-<span class="st"> </span>ames[<span class="op">-</span>index_<span class="dv">1</span>, ]

<span class="co"># caret package</span>
<span class="kw">set.seed</span>(<span class="dv">123</span>)
index_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">createDataPartition</span>(ames<span class="op">$</span>Sale_Price, <span class="dt">p =</span> <span class="fl">0.7</span>, <span class="dt">list =</span> <span class="ot">FALSE</span>)
train_<span class="dv">2</span> &lt;-<span class="st"> </span>ames[index_<span class="dv">2</span>, ]
test_<span class="dv">2</span>  &lt;-<span class="st"> </span>ames[<span class="op">-</span>index_<span class="dv">2</span>, ]

<span class="co"># rsample package</span>
<span class="kw">set.seed</span>(<span class="dv">123</span>)
split_<span class="dv">1</span>  &lt;-<span class="st"> </span><span class="kw">initial_split</span>(ames, <span class="dt">prop =</span> <span class="fl">0.7</span>)
train_<span class="dv">3</span>  &lt;-<span class="st"> </span><span class="kw">training</span>(split_<span class="dv">1</span>)
test_<span class="dv">3</span>   &lt;-<span class="st"> </span><span class="kw">testing</span>(split_<span class="dv">1</span>)

<span class="co"># h2o package</span>
split_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">h2o.splitFrame</span>(ames.h2o, <span class="dt">ratios =</span> <span class="fl">0.7</span>, <span class="dt">seed =</span> <span class="dv">123</span>)
train_<span class="dv">4</span> &lt;-<span class="st"> </span>split_<span class="dv">2</span>[[<span class="dv">1</span>]]
test_<span class="dv">4</span>  &lt;-<span class="st"> </span>split_<span class="dv">2</span>[[<span class="dv">2</span>]]</code></pre></div>
<p>Since this sampling approach will randomly sample across the distribution of <span class="math inline">\(y\)</span> (<code>Sale_Price</code> in our example), you will typically result in a similar distribution between your training and test sets as illustrated below.</p>
<div class="figure" style="text-align: center"><span id="fig:distributions"></span>
<img src="02-ml-strategy_files/figure-html/distributions-1.png" alt="Training (black) vs. test (red) distribution." width="864" />
<p class="caption">
Figure 2.2: Training (black) vs. test (red) distribution.
</p>
</div>
</div>
<div id="stratified-sampling" class="section level3">
<h3><span class="header-section-number">2.2.3</span> Stratified sampling</h3>
<p>However, if we want to explicitly control our sampling so that our training and test sets have similar <span class="math inline">\(y\)</span> distributions, we can use stratified sampling. This is more common with classification problems where the reponse variable may be imbalanced (90% of observations with response “Yes” and 10% with response “No”). However, we can also apply to regression problems for data sets that have a small sample size and where the response variable deviates strongly from normality. With a continuous response variable, stratified sampling will break <span class="math inline">\(y\)</span> down into quantiles and randomly sample from each quantile. Consequently, this will help ensure a balanced representation of the response distribution in both the training and test sets.</p>
<p>The easiest way to perform stratified sampling on a response variable is to use the <strong>rsample</strong> package, where you specify the response variable to <code>strata</code>fy. The following illustrates that in our original employee attrition data we have an imbalanced response (No: 84%, Yes: 16%). By enforcing stratified sampling both our training and testing sets have approximately equal response distributions.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># orginal response distribution</span>
<span class="kw">table</span>(churn<span class="op">$</span>Attrition) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">prop.table</span>()
## 
##        No       Yes 
## 0.8387755 0.1612245

<span class="co"># stratified sampling with the rsample package</span>
<span class="kw">set.seed</span>(<span class="dv">123</span>)
split_strat  &lt;-<span class="st"> </span><span class="kw">initial_split</span>(churn, <span class="dt">prop =</span> <span class="fl">0.7</span>, <span class="dt">strata =</span> <span class="st">&quot;Attrition&quot;</span>)
train_strat  &lt;-<span class="st"> </span><span class="kw">training</span>(split_strat)
test_strat   &lt;-<span class="st"> </span><span class="kw">testing</span>(split_strat)

<span class="co"># consistent response ratio between train &amp; test</span>
<span class="kw">table</span>(train_strat<span class="op">$</span>Attrition) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">prop.table</span>()
## 
##       No      Yes 
## 0.838835 0.161165
<span class="kw">table</span>(test_strat<span class="op">$</span>Attrition) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">prop.table</span>()
## 
##        No       Yes 
## 0.8386364 0.1613636</code></pre></div>
</div>
</div>
<div id="reg_perf_feat" class="section level2">
<h2><span class="header-section-number">2.3</span> Feature engineering</h2>
<p><strong><em>Feature engineering</em></strong> generally refers to the process of adding, deleting, and transforming the variables to be applied to your machine learning algorithms. Feature engineering is a significant process and requires you to spend substantial time understanding your data…or as Leo Breiman said <em>“live with your data before you plunge into modeling.”</em></p>
<p>Although this book primarily focuses on applying machine learning algorithms, feature engineering can make or break an algorithm’s predictive ability. We will not cover all the potential ways of implementing feature engineering; however, we will cover a few fundamental pre-processing tasks that can significantly improve modeling performance. To learn more about feature engineering check out <a href="http://shop.oreilly.com/product/0636920049081.do">Feature Engineering for Machine Learning</a> by <span class="citation">Zheng and Casari (<a href="#ref-zheng2018feature">2018</a>)</span> and Max Kuhn’s upcoming book <a href="http://www.feat.engineering/">Feature Engineering and Selection: A Practical Approach for Predictive Models</a>.</p>
<div id="response-transformation" class="section level3">
<h3><span class="header-section-number">2.3.1</span> Response Transformation</h3>
<p>Although not a requirement, normalizing the distribution of the response variable by using a <em>transformation</em> can lead to a big improvement, especially for parametric models. As we saw in the data splitting section, our response variable <code>Sale_Price</code> is right skewed.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(train_<span class="dv">1</span>, <span class="kw">aes</span>(<span class="dt">x =</span> Sale_Price)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_density</span>(<span class="dt">trim =</span> <span class="ot">TRUE</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_density</span>(<span class="dt">data =</span> test_<span class="dv">1</span>, <span class="dt">trim =</span> <span class="ot">TRUE</span>, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:skewedresponse"></span>
<img src="02-ml-strategy_files/figure-html/skewedresponse-1.png" alt="Right skewed response variable." width="672" />
<p class="caption">
Figure 2.3: Right skewed response variable.
</p>
</div>
<p>To normalize, we have a few options:</p>
<p><strong>Option 1</strong>: normalize with a log transformation. This will transform most right skewed distributions to be approximately normal.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># log transformation</span>
train_log_y &lt;-<span class="st"> </span><span class="kw">log</span>(train_<span class="dv">1</span><span class="op">$</span>Sale_Price)
test_log_y  &lt;-<span class="st"> </span><span class="kw">log</span>(test_<span class="dv">1</span><span class="op">$</span>Sale_Price)</code></pre></div>
<p>If your reponse has negative values then a log transformation will produce <code>NaN</code>s. If these negative values are small (between -0.99 and 0) then you can apply <code>log1p</code>, which adds 1 to the value prior to applying a log transformation. If your data consists of negative equal to or less than -1, use the Yeo Johnson transformation mentioned next.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">log</span>(<span class="op">-</span>.<span class="dv">5</span>)
## [1] NaN
<span class="kw">log1p</span>(<span class="op">-</span>.<span class="dv">5</span>)
## [1] -0.6931472</code></pre></div>
<p><strong>Option 2</strong>: use a Box Cox transformation. A Box Cox transformation is more flexible and will find the transformation from a family of <a href="https://en.wikipedia.org/wiki/Power_transform#Box%E2%80%93Cox_transformation">power transforms</a> that will transform the variable as close as possible to a normal distribution.</p>
<div class="rmdwarning">
<p>
Be sure to compute the <code>lambda</code> on the training set and apply that same <code>lambda</code> to both the training and test set to minimize data leakage.
</p>
</div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Box Cox transformation</span>
lambda  &lt;-<span class="st"> </span>forecast<span class="op">::</span><span class="kw">BoxCox.lambda</span>(train_<span class="dv">1</span><span class="op">$</span>Sale_Price)
train_bc_y &lt;-<span class="st"> </span>forecast<span class="op">::</span><span class="kw">BoxCox</span>(train_<span class="dv">1</span><span class="op">$</span>Sale_Price, lambda)
test_bc_y  &lt;-<span class="st"> </span>forecast<span class="op">::</span><span class="kw">BoxCox</span>(test_<span class="dv">1</span><span class="op">$</span>Sale_Price, lambda)</code></pre></div>
<p>We can see that in this example, the log transformation and Box Cox transformation both do about equally well in transforming our reponse variable to be normally distributed.</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-5"></span>
<img src="02-ml-strategy_files/figure-html/unnamed-chunk-5-1.png" alt="Response variable transformations." width="864" />
<p class="caption">
Figure 2.4: Response variable transformations.
</p>
</div>
<p>Note that when you model with a transformed response variable, your predictions will also be in the transformed value. You will likely want to re-transform your predicted values back to their normal state so that decision-makers can interpret the results. The following code can do this for you:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># log transform a value</span>
y &lt;-<span class="st"> </span><span class="kw">log</span>(<span class="dv">10</span>)

<span class="co"># re-transforming the log-transformed value</span>
<span class="kw">exp</span>(y)
## [1] 10

<span class="co"># Box Cox transform a value</span>
y &lt;-<span class="st"> </span>forecast<span class="op">::</span><span class="kw">BoxCox</span>(<span class="dv">10</span>, lambda)

<span class="co"># Inverse Box Cox function</span>
inv_box_cox &lt;-<span class="st"> </span><span class="cf">function</span>(x, lambda) {
  <span class="cf">if</span> (lambda <span class="op">==</span><span class="st"> </span><span class="dv">0</span>) <span class="kw">exp</span>(x) <span class="cf">else</span> (lambda<span class="op">*</span>x <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)<span class="op">^</span>(<span class="dv">1</span><span class="op">/</span>lambda) 
}

<span class="co"># re-transforming the Box Cox-transformed value</span>
<span class="kw">inv_box_cox</span>(y, lambda)
## [1] 10
## attr(,&quot;lambda&quot;)
## [1] -0.3067918</code></pre></div>
<div class="rmdtip">
<p>
If your response has negative values, you can use the Yeo-Johnson transformation. To apply, use <code>car::powerTransform</code> to identify the lambda, <code>car::yjPower</code> to apply the transformation, and <code>VGAM::yeo.johnson</code> to apply the transformation and/or the inverse transformation.
</p>
</div>
</div>
<div id="predictor-transformation" class="section level3">
<h3><span class="header-section-number">2.3.2</span> Predictor Transformation</h3>
</div>
<div id="one-hot-encoding" class="section level3">
<h3><span class="header-section-number">2.3.3</span> One-hot encoding</h3>
<p>Many models require all predictor variables to be numeric. Consequently, we need to transform any categorical variables into numeric representations so that these algorithms can compute. Some packages automate this process (i.e. <code>h2o</code>, <code>glm</code>, <code>caret</code>) while others do not (i.e. <code>glmnet</code>, <code>keras</code>). Furthermore, there are many ways to encode categorical variables as numeric representations (i.e. one-hot, ordinal, binary, sum, Helmert).</p>
<p>The most common is referred to as one-hot encoding, where we transpose our categorical variables so that each level of the feature is represented as a boolean value. For example, one-hot encoding variable <code>x</code> in the following:</p>
<table>
<thead>
<tr class="header">
<th align="right">id</th>
<th align="left">x</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="left">a</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="left">c</td>
</tr>
<tr class="odd">
<td align="right">3</td>
<td align="left">b</td>
</tr>
<tr class="even">
<td align="right">4</td>
<td align="left">c</td>
</tr>
<tr class="odd">
<td align="right">5</td>
<td align="left">c</td>
</tr>
<tr class="even">
<td align="right">6</td>
<td align="left">a</td>
</tr>
<tr class="odd">
<td align="right">7</td>
<td align="left">b</td>
</tr>
<tr class="even">
<td align="right">8</td>
<td align="left">c</td>
</tr>
</tbody>
</table>
<p>results in the following representation:</p>
<table>
<thead>
<tr class="header">
<th align="right">id</th>
<th align="right">x.a</th>
<th align="right">x.b</th>
<th align="right">x.c</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="right">3</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">4</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="right">5</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="right">6</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td align="right">7</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">8</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
</tbody>
</table>
<p>This is called less than <em>full rank</em> encoding where we retain all variables for each level of <code>x</code>. However, this creates perfect collinearity which causes problems with some machine learning algorithms (i.e. generalized regression models, neural networks). Alternatively, we can create full-rank one-hot encoding by dropping one of the levels (level <code>a</code> has been dropped):</p>
<table>
<thead>
<tr class="header">
<th align="right">id</th>
<th align="right">x.b</th>
<th align="right">x.c</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="right">3</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">4</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="right">5</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="right">6</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td align="right">7</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">8</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
</tbody>
</table>
<p>If you needed to manually implement one-hot encoding yourself you can with <code>caret::dummyVars</code>. Sometimes you may have a feature level with very few observations and all these observations show up in the test set but not the training set. The benefit of using <code>dummyVars</code> on the full data set and then applying the result to both the train and test data sets is that it will guarantee that the same features are represented in both the train and test data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># full rank one-hot encode - recommended for generalized linear models and</span>
<span class="co"># neural networks</span>
full_rank  &lt;-<span class="st"> </span><span class="kw">dummyVars</span>( <span class="op">~</span><span class="st"> </span>., <span class="dt">data =</span> ames, <span class="dt">fullRank =</span> <span class="ot">TRUE</span>)
train_oh   &lt;-<span class="st"> </span><span class="kw">predict</span>(full_rank, train_<span class="dv">1</span>)
test_oh    &lt;-<span class="st"> </span><span class="kw">predict</span>(full_rank, test_<span class="dv">1</span>)

<span class="co"># less than full rank --&gt; dummy encoding</span>
dummy    &lt;-<span class="st"> </span><span class="kw">dummyVars</span>( <span class="op">~</span><span class="st"> </span>., <span class="dt">data =</span> ames, <span class="dt">fullRank =</span> <span class="ot">FALSE</span>)
train_oh &lt;-<span class="st"> </span><span class="kw">predict</span>(dummy, train_<span class="dv">1</span>)
test_oh  &lt;-<span class="st"> </span><span class="kw">predict</span>(dummy, test_<span class="dv">1</span>)</code></pre></div>
<p>Two things to note:</p>
<ul>
<li><p>since one-hot encoding adds new features it can significantly increase the dimensionality of our data. If you have a data set with many categorical variables and those categorical variables in turn have many unique levels, the number of features can explode. In these cases you may want to explore ordinal encoding of your data.</p></li>
<li><p>if using <code>h2o</code> you do not need to explicity encode your categorical predictor variables but you can override the default encoding. This can be considered a tuning parameter as some encoding approaches will improve modeling accuracy over other encodings. See the encoding options for <code>h2o</code> <a href="http://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science/algo-params/categorical_encoding.html">here</a>.</p></li>
</ul>
</div>
<div id="standardizing" class="section level3">
<h3><span class="header-section-number">2.3.4</span> Standardizing</h3>
<p>Some models (<em>K</em>-NN, SVMs, PLS, neural networks) require that the predictor variables have the same units. <strong>Centering</strong> and <strong>scaling</strong> can be used for this purpose and is often referred to as <strong><em>standardizing</em></strong> the features. Standardizing numeric variables results in zero mean and unit variance, which provides a common comparable unit of measure across all the variables.</p>
<p>Some packages have built-in arguments (i.e. <code>h2o</code>, <code>caret</code>) to standardize and some do not (i.e. <code>glm</code>, <code>keras</code>). If you need to manually standardize your variables you can use the <code>preProcess</code> function provided by the <code>caret</code> package. For example, here we center and scale our Ames predictor variables.</p>
<div class="rmdwarning">
<p>
It is important that you standardize the test data based on the training mean and variance values of each feature. This minimizes data leakage.
</p>
</div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># identify only the predictor variables</span>
features &lt;-<span class="st"> </span><span class="kw">setdiff</span>(<span class="kw">names</span>(train_<span class="dv">1</span>), <span class="st">&quot;Sale_Price&quot;</span>)

<span class="co"># pre-process estimation based on training features</span>
pre_process &lt;-<span class="st"> </span><span class="kw">preProcess</span>(
  <span class="dt">x      =</span> train_<span class="dv">1</span>[, features],
  <span class="dt">method =</span> <span class="kw">c</span>(<span class="st">&quot;center&quot;</span>, <span class="st">&quot;scale&quot;</span>)    
  )

<span class="co"># apply to both training &amp; test</span>
train_x &lt;-<span class="st"> </span><span class="kw">predict</span>(pre_process, train_<span class="dv">1</span>[, features])
test_x  &lt;-<span class="st"> </span><span class="kw">predict</span>(pre_process, test_<span class="dv">1</span>[, features])</code></pre></div>
</div>
<div id="alternative-feature-transformation" class="section level3">
<h3><span class="header-section-number">2.3.5</span> Alternative Feature Transformation</h3>
<p>There are some alternative transformations that you can perform:</p>
<ul>
<li><p>Normalizing the predictor variables with a Box Cox transformation can improve parametric model performance.</p></li>
<li><p>Collapsing highly correlated variables with PCA can reduce the number of features and increase the stability of generalize linear models. However, this reduces the amount of information at your disposal and we show you how to use regularization as a better alternative to PCA.</p></li>
<li><p>Removing near-zero or zero variance variables. Variables with vary little variance tend to not improve model performance and can be removed.</p></li>
</ul>
<div class="rmdtip">
<p>
<code>preProcess</code> provides many other transformation options which you can read more about <a href="https://topepo.github.io/caret/pre-processing.html">here</a>.
</p>
</div>
<p>For example, the following normalizes predictors with a Box Cox transformation, center and scales continuous variables, performs principal component analysis to reduce the predictor dimensions, and removes predictors with near zero variance.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># identify only the predictor variables</span>
features &lt;-<span class="st"> </span><span class="kw">setdiff</span>(<span class="kw">names</span>(train_<span class="dv">1</span>), <span class="st">&quot;Sale_Price&quot;</span>)

<span class="co"># pre-process estimation based on training features</span>
pre_process &lt;-<span class="st"> </span><span class="kw">preProcess</span>(
  <span class="dt">x      =</span> train_<span class="dv">1</span>[, features],
  <span class="dt">method =</span> <span class="kw">c</span>(<span class="st">&quot;BoxCox&quot;</span>, <span class="st">&quot;center&quot;</span>, <span class="st">&quot;scale&quot;</span>, <span class="st">&quot;pca&quot;</span>, <span class="st">&quot;nzv&quot;</span>)    
  )

<span class="co"># apply to both training &amp; test</span>
train_x &lt;-<span class="st"> </span><span class="kw">predict</span>(pre_process, train_<span class="dv">1</span>[, features])
test_x  &lt;-<span class="st"> </span><span class="kw">predict</span>(pre_process, test_<span class="dv">1</span>[, features])</code></pre></div>
</div>
</div>
<div id="reg_perf_model" class="section level2">
<h2><span class="header-section-number">2.4</span> Basic model formulation</h2>
<p>There are <strong><em>many</em></strong> packages to perform machine learning and there are almost always more than one to perform each algorithm (i.e. there are over 20 packages to perform random forests). There are pros and cons to each package; some may be more computationally efficient while others may have more hyperparameter tuning options. Future chapters will expose you to many of the packages and algorithms that perform and scale best to most organization’s problems and data sets. Just realize there are <em>more ways than one to skin a</em> 🙀.</p>
<p>For example, these three functions will all produce the same linear regression model output.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lm.lm    &lt;-<span class="st"> </span><span class="kw">lm</span>(Sale_Price <span class="op">~</span><span class="st"> </span>., <span class="dt">data =</span> train_<span class="dv">1</span>)
lm.glm   &lt;-<span class="st"> </span><span class="kw">glm</span>(Sale_Price <span class="op">~</span><span class="st"> </span>., <span class="dt">data =</span> train_<span class="dv">1</span>, <span class="dt">family =</span> gaussian)
lm.caret &lt;-<span class="st"> </span><span class="kw">train</span>(Sale_Price <span class="op">~</span><span class="st"> </span>., <span class="dt">data =</span> train_<span class="dv">1</span>, <span class="dt">method =</span> <span class="st">&quot;lm&quot;</span>)</code></pre></div>
<p>One thing you will notice throughout this guide is that we can specify our model formulation in different ways. In the above examples we use the <em>model formulation</em> (<code>Sale_Price ~ .</code> which says explain <code>Sale_Price</code> based on all features) approach. Alternative approaches, which you will see more often throughout this guide, are the matrix formulation and variable name specification approaches.</p>
<p><em>Matrix formulation</em> requires that we separate our response variable from our features. For example, in the regularization section we’ll use <code>glmnet</code> which requires our features (<code>x</code>) and response (<code>y</code>) variable to be specified separately:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get feature names</span>
features &lt;-<span class="st"> </span><span class="kw">setdiff</span>(<span class="kw">names</span>(train_<span class="dv">1</span>), <span class="st">&quot;Sale_Price&quot;</span>)

<span class="co"># create feature and response set</span>
train_x &lt;-<span class="st"> </span>train_<span class="dv">1</span>[, features]
train_y &lt;-<span class="st"> </span>train_<span class="dv">1</span><span class="op">$</span>Sale_Price

<span class="co"># example of matrix formulation</span>
glmnet.m1 &lt;-<span class="st"> </span><span class="kw">glmnet</span>(<span class="dt">x =</span> train_x, <span class="dt">y =</span> train_y)</code></pre></div>
<p>Alternatively, <code>h2o</code> uses <em>variable name specification</em> where we provide all the data combined in one <code>training_frame</code> but we specify the features and response with character strings:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># create variable names and h2o training frame</span>
y &lt;-<span class="st"> &quot;Sale_Price&quot;</span>
x &lt;-<span class="st"> </span><span class="kw">setdiff</span>(<span class="kw">names</span>(train_<span class="dv">1</span>), y)
train.h2o &lt;-<span class="st"> </span><span class="kw">as.h2o</span>(train_<span class="dv">1</span>)

<span class="co"># example of variable name specification</span>
h2o.m1 &lt;-<span class="st"> </span><span class="kw">h2o.glm</span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y, <span class="dt">training_frame =</span> train.h2o)</code></pre></div>
</div>
<div id="reg_perf_tune" class="section level2">
<h2><span class="header-section-number">2.5</span> Model tuning</h2>
<p>Hyperparameters control the level of model complexity. Some algorithms have many tuning parameters while others have only one or two. Tuning can be a good thing as it allows us to transform our model to better align with patterns within our data. For example, the simple illustration below shows how the more flexible model aligns more closely to the data than the fixed linear model.</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-14"></span>
<img src="02-ml-strategy_files/figure-html/unnamed-chunk-14-1.png" alt="Tuning allows for more flexible patterns to be fit." width="672" />
<p class="caption">
Figure 2.5: Tuning allows for more flexible patterns to be fit.
</p>
</div>
<p>However, highly tunable models can also be dangerous because they allow us to overfit our model to the training data, which will not generalize well to future unseen data.</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-15"></span>
<img src="02-ml-strategy_files/figure-html/unnamed-chunk-15-1.png" alt="Highly tunable models can overfit if we are not careful." width="864" />
<p class="caption">
Figure 2.6: Highly tunable models can overfit if we are not careful.
</p>
</div>
<p>Throughout this guide we will demonstrate how to tune the different parameters for each model. One way to performing hyperparameter tuning is to fiddle with hyperparameters manually until you find a great combination of hyperparameter values that result in high predictive accuracy. However, this would be very tedious work. An alternative approach is to perform a <strong><em>grid search</em></strong>. A grid search is an automated approach to searching across many combinations of hyperparameter values. Throughout this guide you will be exposed to different approaches to performing grid searches.</p>
</div>
<div id="cv" class="section level2">
<h2><span class="header-section-number">2.6</span> Cross Validation for Generalization</h2>
<p>Our goal is to not only find a model that performs well on training data but to find one that performs well on <em>future unseen data</em>. So although we can tune our model to reduce some error metric to near zero on our training data, this may not generalize well to future unseen data. Consequently, our goal is to find a model and its hyperparameters that will minimize error on held-out data.</p>
<p>Let’s go back to this image…</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-16"></span>
<img src="02-ml-strategy_files/figure-html/unnamed-chunk-16-1.png" alt="Bias versus variance." width="864" />
<p class="caption">
Figure 2.7: Bias versus variance.
</p>
</div>
<p>The model on the left is considered rigid and consistent. If we provided it a new training sample with slightly different values, the model would not change much, if at all. Although it is consistent, the model does not accurately capture the underlying relationship. This is considered a model with high <strong><em>bias</em></strong>.</p>
<p>The model on the right is far more inconsistent. Even with small changes to our training sample, this model would likely change significantly. This is considered a model with high <strong><em>variance</em></strong>.</p>
<p>The model in the middle balances the two and, likely, will minimize the error on future unseen data compared to the high bias and high variance models. This is our goal.</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-17"></span>
<img src="images/bias_var.png" alt="Bias-variance tradeoff."  />
<p class="caption">
Figure 2.8: Bias-variance tradeoff.
</p>
</div>
<p>To find the model that balances the <strong><em>bias-variance tradeoff</em></strong>, we search for a model that minimizes a <em>k</em>-fold cross-validation error metric. <em>k</em>-fold cross-validation is a resampling method that randomly divides the training data into <em>k</em> groups (aka folds) of approximately equal size. The model is fit on <span class="math inline">\(k-1\)</span> folds and then the held-out validation fold is used to compute the error. This procedure is repeated <em>k</em> times; each time, a different group of observations is treated as the validation set. This process results in <em>k</em> estimates of the test error (<span class="math inline">\(\epsilon_1, \epsilon_2, \dots, \epsilon_k\)</span>). Thus, the <em>k</em>-fold CV estimate is computed by averaging these values, which provides us with an approximation of the error to expect on unseen data.</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-18"></span>
<img src="images/cv.png" alt="Illustration of the k-fold cross validation process."  />
<p class="caption">
Figure 2.9: Illustration of the k-fold cross validation process.
</p>
</div>
<p>The algorithms we cover in this guide all have built-in cross validation capabilities. One typically uses a 5 or 10 fold CV (<span class="math inline">\(k = 5\)</span> or <span class="math inline">\(k = 10\)</span>). For example, <code>h2o</code> implements CV with the <code>nfolds</code> argument:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># example of 10 fold CV in h2o</span>
h2o.cv &lt;-<span class="st"> </span><span class="kw">h2o.glm</span>(
  <span class="dt">x =</span> x, 
  <span class="dt">y =</span> y, 
  <span class="dt">training_frame =</span> train.h2o,
  <span class="dt">nfolds =</span> <span class="dv">10</span>
  )</code></pre></div>
</div>
<div id="reg_perf_eval" class="section level2">
<h2><span class="header-section-number">2.7</span> Model evaluation</h2>
<p>This leads us to our final topic, error metrics to evaluate performance. There are several metrics we can choose from to assess the error of a supervised machine learning model. The most common include:</p>
<div id="regression-models" class="section level3">
<h3><span class="header-section-number">2.7.1</span> Regression models</h3>
<ul>
<li><p><strong>MSE</strong>: Mean squared error is the average of the squared error (<span class="math inline">\(MSE = \frac{1}{n} \sum^n_{i=1}(y_i - \hat y_i)^2\)</span>). The squared component results in larger errors having larger penalties. This (along with RMSE) is the most common error metric to use. <strong>Objective: minimize</strong></p></li>
<li><p><strong>RMSE</strong>: Root mean squared error. This simply takes the square root of the MSE metric (<span class="math inline">\(RMSE = \sqrt{\frac{1}{n} \sum^n_{i=1}(y_i - \hat y_i)^2}\)</span>) so that your error is in the same units as your response variable. If your response variable units are dollars, the units of MSE are dollars-squared, but the RMSE will be in dollars. <strong>Objective: minimize</strong></p></li>
<li><p><strong>Deviance</strong>: Short for mean residual deviance. In essence, it provides a measure of <em>goodness-of-fit</em> of the model being evaluated when compared to the null model (intercept only). If the response variable distribution is gaussian, then it is equal to MSE. When not, it usually gives a more useful estimate of error. <strong>Objective: minimize</strong></p></li>
<li><p><strong>MAE</strong>: Mean absolute error. Similar to MSE but rather than squaring, it just takes the mean absolute difference between the actual and predicted values (<span class="math inline">\(MAE = \frac{1}{n} \sum^n_{i=1}(\vert y_i - \hat y_i \vert)\)</span>). <strong>Objective: minimize</strong></p></li>
<li><p><strong>RMSLE</strong>: Root mean squared logarithmic error. Similiar to RMSE but it performs a log() on the actual and predicted values prior to computing the difference (<span class="math inline">\(RMSLE = \sqrt{\frac{1}{n} \sum^n_{i=1}(log(y_i + 1) - log(\hat y_i + 1))^2}\)</span>). When your response variable has a wide range of values, large repsonse values with large errors can dominate the MSE/RMSE metric. RMSLE minimizes this impact so that small response values with large errors can have just as meaningful of an impact as large response values with large errors. <strong>Objective: minimize</strong></p></li>
<li><p><strong><span class="math inline">\(R^2\)</span></strong>: This is a popular metric that represents the proportion of the variance in the dependent variable that is predictable from the independent variable. Unfortunately, it has several limitations. For example, two models built from two different data sets could have the exact same RMSE but if one has less variability in the response variable then it would have a lower <span class="math inline">\(R^2\)</span> than the other. You should not place too much emphasis on this metric. <strong>Objective: maximize</strong></p></li>
</ul>
<p>Most models we assess in this guide will report most, if not all, of these metrics. We will emphasize MSE and RMSE but its good to realize that certain situations warrant emphasis on some more than others.</p>
</div>
<div id="classification-models" class="section level3">
<h3><span class="header-section-number">2.7.2</span> Classification models</h3>
<ul>
<li><p><strong>Misclassification</strong>: This is the overall error. For example, say you are predicting 3 classes ( <em>high</em>, <em>medium</em>, <em>low</em> ) and each class has 25, 30, 35 observations respectively (90 observations total). If you misclassify 3 observations of class <em>high</em>, 6 of class <em>medium</em>, and 4 of class <em>low</em>, then you misclassified 13 out of 90 observations resulting in a 14% misclassification rate. <strong>Objective: minimize</strong></p></li>
<li><p><strong>Mean per class error</strong>: This is the average error rate for each class. For the above example, this would be the mean of <span class="math inline">\(\frac{3}{25}, \frac{6}{30}, \frac{4}{35}\)</span>, which is 12%. If your classes are balanced this will be identical to misclassification. <strong>Objective: minimize</strong></p></li>
<li><p><strong>MSE</strong>: Mean squared error. Computes the distance from 1.0 to the probability suggested. So, say we have three classes, A, B, and C, and your model predicts a probabilty of 0.91 for A, 0.07 for B, and 0.02 for C. If the correct answer was A the <span class="math inline">\(MSE = 0.09^2 = 0.0081\)</span>, if it is B <span class="math inline">\(MSE = 0.93^2 = 0.8649\)</span>, if it is C <span class="math inline">\(MSE = 0.98^2 = 0.9604\)</span>. The squared component results in large differences in probabilities for the true class having larger penalties. <strong>Objective: minimize</strong></p></li>
<li><p><strong>Cross-entropy (aka Log Loss or Deviance)</strong>: Similar to MSE but it incorporates a log of the predicted probability multiplied by the true class. Consequently, this metric disproportionately punishes predictions where we predict a small probability for the true class, which is another way of saying having high confidence in the wrong answer is really bad. <strong>Objective: minimize</strong></p></li>
<li><p><strong>Gini index</strong>: Mainly used with tree-based methods and commonly referred to as a measure of <em>purity</em> where a small value indicates that a node contains predominantly observations from a single class. <strong>Objective: minimize</strong></p></li>
</ul>
<p>When applying classification models, we often use a <em>confusion matrix</em> to evaluate certain performance measures. A confusion matrix is simply a matrix that compares actual categorical levels (or events) to the predicted categorical levels. When we predict the right level, we refer to this as a <em>true positive</em>. However, if we predict a level or event that did not happen this is called a <em>false positive</em> (i.e. we predicted a customer would redeem a coupon and they did not). Alternatively, when we do not predict a level or event and it does happen that this is called a <em>false negative</em> (i.e. a customer that we did not predict to redeem a coupon does).</p>
<div class="figure" style="text-align: center"><span id="fig:confusion-matrix"></span>
<img src="images/confusion-matrix.png" alt="Confusion matrix." width="100%" height="100%" />
<p class="caption">
Figure 2.10: Confusion matrix.
</p>
</div>
<p>We can extract different levels of performance from these measures. For example, given the classification matrix below we can assess the following:</p>
<ul>
<li><p><strong>Accuracy</strong>: Overall, how often is the classifier correct? Opposite of misclassification above. Example: <span class="math inline">\(\frac{TP + TN}{total} = \frac{100+50}{165} = 0.91\)</span>. <strong>Objective: maximize</strong></p></li>
<li><p><strong>Precision</strong>: How accurately does the classifier predict events? This metric is concerned with maximizing the true positives to false positive ratio. In other words, for the number of predictions that we made, how many were correct? Example: <span class="math inline">\(\frac{TP}{TP + FP} = \frac{100}{100+10} = 0.91\)</span>. <strong>Objective: maximize</strong></p></li>
<li><p><strong>Sensitivity (aka recall)</strong>: How accurately does the classifier classify actual events? This metric is concerned with maximizing the true positives to false negatives ratio. In other words, for the events that occurred, how many did we predict? Example: <span class="math inline">\(\frac{TP}{TP + FN} = \frac{100}{100+5} = 0.95\)</span>. <strong>Objective: maximize</strong></p></li>
<li><p><strong>Specificity</strong>: How accurately does the classifier classify actual non-events? Example: <span class="math inline">\(\frac{TN}{TN + FP} = \frac{50}{50+10} = 0.83\)</span>. <strong>Objective: maximize</strong></p></li>
</ul>
<div class="figure" style="text-align: center"><span id="fig:confusion-matrix2"></span>
<img src="images/confusion-matrix2.png" alt="Example confusion matrix." width="50%" height="50%" />
<p class="caption">
Figure 2.11: Example confusion matrix.
</p>
</div>
<ul>
<li><strong>AUC</strong>: Area under the curve. A good classifier will have high precision and sensitivity. This means the classifier does well when it predicts an event will and will not occur, which minimizes false positives and false negatives. To capture this balance, we often use a ROC curve that plots the false positive rate along the x-axis and the true positive rate along the y-axis. A line that is diagonal from the lower left corner to the upper right corner represents a random guess. The higher the line is in the upper left-hand corner, the better. AUC computes the area under this curve. <strong>Objective: maximize</strong></li>
</ul>
<div class="figure" style="text-align: center"><span id="fig:roc"></span>
<img src="images/roc.png" alt="ROC curve." width="75%" height="75%" />
<p class="caption">
Figure 2.12: ROC curve.
</p>
</div>

</div>
</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-zheng2018feature">
<p>Zheng, Alice, and Amanda Casari. 2018. <em>Feature Engineering for Machine Learning: Principles and Techniques for Data Scientists</em>. “ O’Reilly Media, Inc.”</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="intro.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="regularized-regression.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/rstudio/bookdown-demo/edit/master/02-ml-strategy.rmd",
"text": "Edit"
},
"download": ["hands-on-machine-learning-with-R.pdf", "hands-on-machine-learning-with-R.epub"],
"toc": {
"collapse": "section"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
